package homework_lesson5;
// Здесь должны бытьь задания с листочка Phone
public class Class {
public static void main(String[] args) {
/*Класс определяется с помощью ключевого слова class:
 *	class Person{
 *		//Тело класса, т.е. его поля и методы
 *}
 *В данном случае, класс называется Person. После названия класса, идут фигурные скобки, между которыми помещается тело класса - т.е. его поля и
 *методы
 *	Любой объект может обладать 2-мя основными характеристиками: состояние - некоторые данные, которые хранит объект, и поведение - действия, кото-
 *рое может своершать объект.
 *	Для хранения состояния объекта в классе применяются поля или переменные класса. Для определения поведения объекта в классе применяются методы.
 *Напрмер, класс Person, который представляет человека, мог бы иметь следующее описание:
 *
 * class Person {
 * 
 * String name;
 * int age;														<--- Тело класса
 * void displayInfo(){
 * 	System.out.printf("Name :s \tAge: %d\n", name, age);
 * 	}
 * }
 * 
 * В классе Person определены 2 поля: name представляет имя человека, а age - его возраст. И так же определен метод displayInfo, который ничего не
 * возвращает и просто выводит эти данные на консоль.
 * Теперь используем данный класс. Для этого определим следующую программу:*/	
//Person tom;
//	}								<--- Скобки от public и psvm
//}
//class Person{
//	String name;
//	int age;
//	void displayInfo() {
//		System.out.printf("Name :s \tAge: %d\n", name, age);
//	}
/*	Как правило классы определятся в разных файлах. Cтоит отметить, что если 2 класса определяются в одном файле, только один из них может иметь
 *модификатор public
 *	Класс представляет новый тип, поэтому мы можем определять переменные, которые представляют данный тип. Здесь, в методе main определена перемен-
 *ная tom, которая представляет класс Person. Но пока эта переменная не указывает ни на какой объект и по умолчанию имеет значение null. По большому
 *счету мы ее пока не можем использовать, поэтому вначале необходимо создать объект класса Person 	
 *	Конструкторы
 *	Кроме обычных методов классы могут определять специальные методы, которые называются конструкторами. Конструкторы вызываются при создании нового
 *объекта данного класса. Конструкторы выполняют инициализацию объекта.
 *	Если в классе не определено ни одного конструктора, то для этого классаа автоматически создается конструктор без параметровю. Выше определнный 
 *класс Person не имеет никаких конструкторов. Поэтому для него автоматически создается конструктор по умолчанию, который мы может использовать
 *для создания объекта Person.В частности, создадим объект: */	
//	//Person tom;
//		Person tom = new Person();	//Создание объекта класса Person. New - резервирует память под экземпляр данного класса. Person() - конструктор, инци-
//		tom.displayInfo();			//ализирующий объект.
//		//Изменяем имя и возраст
//		tom.name = "Tom";			//Обращаемся к переменным объекта Person
//		tom.age = 34;
//		tom.displayInfo();
//	}								//<--- Скобки от public и psvm
//}
//class Person{
//	String name;
//	int age;
//	void displayInfo() {
//		System.out.printf("Name: %s \tAge: %d\n", name, age);
//	}
//}
/*Если необходимо, чтобы при создании объекта выполнялась какая-то логика, например, чтобы поля класса получали какие-то определенные значения,
 * то можно определить в классе свои конструкторы. Например:*/	
//Person bob = new Person();  //Вызов первого конструктора без параметров
//bob.displayInfo();
//
//Person tom = new Person("Tom");  //Вызов второго конструктора с одним параметром
//tom.displayInfo();
//	
//Person sam = new Person("Sam", 25);  //Вызов третьего конструктора с 2-мя параметрами
//sam.displayInfo();	
//	}
//}
//class Person{
//	String name;	//Имя
//	int age;		//Возраст
//	Person() {
//		name = "Undifiend";
//		age = 18;
//	}
//	Person(String n) {
//		name = n;
//		age = 18;
//	}
//	Person(String n, int a){
//		name = n;
//		age = a;
//	}
//	void displayInfo(){
//		System.out.printf("Name: %s \tAge: %d\n", name, age);
//	}
//}	
/*Теперь в классе определено 3 конструктора, каждый из которых принимает различное кол-во параметров и устанавливает знаение полей класса*/
/*	Ключевое слово this
 *	Ключевое слово this предоставляет ссылку на текущий экземпляр класса. Через это ключевое слово мы можем обращаться к перемнным, методам 
 *объекта, а также вызывать его конструкторы. Напрмер:*/	
Person undef = new Person();  //Вызов первого конструктора без параметров
undef.displayInfo();

Person tom = new Person("Tom");  //Вызов второго конструктора с одним параметром
tom.displayInfo();
	
Person sam = new Person("Sam", 25);  //Вызов третьего конструктора с 2-мя параметрами
sam.displayInfo();	
	}
}
class Person{
	String name;	//Имя
	int age;		//Возраст
	Person() {
		this("Undifined", 18);
	}
	Person(String name) {
		this(name, 18);
	}
	Person(String name, int age){
		this.name = name;
		this.age = age;
	}
	void displayInfo(){
		System.out.printf("Name: %s \tAge: %d\n", name, age);
	}
}		
/*Импорт пакетов и классов
 *Если вам надо использовать классы из других пакетов, то нам надо подключить эти пакеты и классы. Исключение составляют классы из пакета
 *java.lang, которые подключаются в программу автоматически.
 *Например , класс Scanner находится в пакете java.util, поэтому мы можем получить к нему доступ сл. образом:
 *package study;
 *import java.util.Scanner; импорт класса Scanner
 *public class Program {
 *	public static void main (String[] args){
 *		Scanner in = new Scanner(Sysytem.in); 
 * 	}	
 *}
 *	Возможна ситуация, когда мы используем два класса с одним и тем же названием из двух разных пакетов, например класс Date имеется и в пакете
 *java.util и в пакете java.sql. И если нам надо однорвремнно использовать два тих класса, то необходимо указывать полный путь к этим классам
 *в пакете:
 *java.util.Date utilDate = new java.util.Date();
 *java.sql.Date  sql Date = new java.sql.Date();
 *
 * Перегрузка и переопределение (Разные вещи)
 * Перегрузкой называют еще одну версию (или несколько) одного и того же метода. Каждая версия отличается от остальных версии списком аргументов.
 * Сами аргументы могут идентифицировать метод по 3 признакам:
	1.По количеству
	2.По порядку
	3.По типу
 *	Переопределение это изменение тела унаследованного метода от родительского класса в дочернем классе.
 *  В чем разница между "Parent parent = new Child();" и "Child child = new Child(); " ?
 * 		Что parent, что child будут иметь доступ к одним и тем же методам, так зачем писать "Parent parent = new Child();"  и путаться, 
 * если можно написать "Child child = new Child(); " ?
 * 			Наверное поздно отвечаю, но это нужно для полиморфизма - чтобы через указатель на родителя можно было пользоваться потомками. Например, если от класса Parent наследуется не Child, а два класса: Brother и Sister, то через указатель на Parent можно пользоваться обоими классами. Примерно так:
"Parent object;
boolean IsMan;  
//Присовение пола
if (IsMan)
    object = new Brother();
else
   object = new Sister();"
И далее так работать с этим объектом, даже не смотря на то, что в точности неизвестно каким именно классом он является. 
По крайней мере, так я понимаю.

 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * */	
